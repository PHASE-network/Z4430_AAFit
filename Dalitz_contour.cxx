/***************************************************************************** 
 * Project: RooFit                                                           * 
 *                                                                           * 
 * This code was autogenerated by RooClassFactory                            * 
 *****************************************************************************/ 

// Your description goes here... 

#include "Riostream.h" 

#include "Dalitz_contour.h" 
#include "RooAbsReal.h" 
#include "RooAbsCategory.h" 
#include <math.h> 
#include "TMath.h" 

ClassImp(Dalitz_contour) 

 Dalitz_contour::Dalitz_contour(const char *name, const char *title, 
				RooAbsReal& _mKP,
				RooAbsReal& _mPsiP,
				const TString& _psi_nS
				) :
   RooAbsPdf(name,title), 
   mKP("mKP","mKP",this,_mKP),
   mPsiP("mPsiP","mPsiP",this,_mPsiP),
   psi_nS(_psi_nS)
{ 
} 


 Dalitz_contour::Dalitz_contour(const Dalitz_contour& other, const char* name) :  
   RooAbsPdf(other,name), 
   mKP("mKP",this,other.mKP),
   mPsiP("mPsiP",this,other.mPsiP),
   MPsi_nS(other.MPsi_nS),
   psi_nS(other.psi_nS)
 { 

  if (psi_nS.EqualTo("1")) 
    MPsi_nS = MJpsi;
  else if (psi_nS.EqualTo("2"))
    MPsi_nS = MPsi2S;
  else {
    cout <<"psi_nS = " <<psi_nS <<" not allowed at the moment." <<endl;
    return;
  }

 } 



 Double_t Dalitz_contour::evaluate() const 
 { 
   // ENTER EXPRESSION IN TERMS OF VARIABLE ARGUMENTS HERE 

   if ((mKP < MKaon + MPion) || (mKP > MBd - MPsi_nS) || (mPsiP < MPsi_nS + MPion) || (mPsiP > MBd - MKaon))
     return 0.;
   else { // Dalitz border from PDG KINEMATICS 43.4.3.1. 
     Float_t E_P = (mPsiP*mPsiP - MJpsi2 + MPion2)/(2*mPsiP) ;
     Float_t E_K = (MBd2 - mPsiP*mPsiP - MKaon2)/(2*mPsiP) ;
     Float_t E_PpE_K_2 = TMath::Power((E_P + E_K),2);
     Float_t sqrt_E_P2mMP2 = TMath::Sqrt(E_P*E_P - MPion2);
     Float_t sqrt_E_K2mMK2 = TMath::Sqrt(E_K*E_K - MKaon2);
     Float_t mKP2_min = E_PpE_K_2 - TMath::Power(sqrt_E_P2mMP2 + sqrt_E_K2mMK2,2);
     Float_t mKP2_max = E_PpE_K_2 - TMath::Power(sqrt_E_P2mMP2 - sqrt_E_K2mMK2,2);
     if ((mKP*mKP < mKP2_min) || (mKP*mKP > mKP2_max))
       return 0.;
   }

   return 1.0 ; 
 } 



